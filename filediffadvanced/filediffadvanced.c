/*
filediffadvanced.c => provides an advanced diff tool that shows textual and binary differences and performance statistics

Angus Chen
24509614
GitHub: https://github.com/httpsdluc/csc332-group1

Features:
    - text mode: compare line-by-line, show which line numbers differ
    - binary mode: compare byte-by-byte, show differing offsets and values
    - performance statistics: total lines/bytes compared, total differences, elapsed time

Compilation:
    gcc -Wall -Wextra -std=gnu99 -o filediffadvanced filediffadvanced.c
Usage:
    filediffadvanced [options] <file1> <file2>

Options:
    -t, --text     => force text mode comparison
    -b, --binary   => force binary mode comparison
    -s, --stats    => show performance statistics
    -o, --output   => write output to file (default: stdout)
    -h, --help     => show help and exit
    
Exit Codes:
    0 => files are identical
    1 => files differ
    2 => error (invalid arguments, I/O error, etc.)
*/

#include <stdio.h>      // printf, fprintf, fopen, fclose, fread, fwrite, perror
#include <stdlib.h>     // malloc, free, exit, abort
#include <string.h>     // strlen, strcmp, memcmp, memcpy, strerror, memset
#include <unistd.h>     // read, write, close, access
#include <fcntl.h>      // open, O_RDONLY
#include <sys/mman.h>   // mmap, munmap, MAP_PRIVATE, PROT_READ => efficient file mapping
#include <sys/stat.h>   // stat, fstat, struct stat => getting file size and info
#include <getopt.h>     // getopt, getopt_long => command-line option parsing
#include <time.h>       // clock_gettime, struct timespec
#include <ctype.h>      // isprint, isspace => text vs binary detection
#include <signal.h>     // signal, sigaction, SIGINT => handles ctrl+C interruption
#include <errno.h>      // errno, strerror


// global flag for signal handling => sig_atomic_t ensures atomic read/write operations (thread-safe)
// volatile tells compiler this can change unexpectedly (by signal handler)
volatile sig_atomic_t interrupted = 0;

/*----------STRUCTURES------------*/ 

// struct to hold performance stats
typedef struct {
    struct timespec start_time;    
    struct timespec end_time;
    size_t file1_size;  // size of first file (bytes)
    size_t file2_size;  // size of second file (bytes)
    size_t bytes_compared;  
    size_t differences_found;   // number of differences
    int mmap_used;      // if mmap was used
} PerformanceStats;

// struct to hold command-line options
typedef struct {
    int force_text;      // text mode comparison
    int force_binary;    // force binary mode comparison
    int show_stats;      // display performance stats
    char *output_file;   // output file path (NULL for stdout)
} Options;

// signal handler for graceful interruption (ctrl+C)
void signal_handler(int signum) {
    // check if signal is SIGINT (interrupt signal from ctrl+C)
    if (signum == SIGINT) {
        interrupted = 1;     // set global flag to 1 to notify main comparison loops to stop
        fprintf(stderr, "\n[Interrupted by user - cleaning up...]\n");  // print msg to stderr to avoid interfering with output
    }
}

// set up signal handlers to catch interruption signals
void setup_signals(void) {
    struct sigaction sa;    // sigaction struct => more robust than signal()
    memset(&sa, 0, sizeof(sa));     // zero out entire structure to avoid garbage values
    sa.sa_handler = signal_handler;    // set custom handler function
    sigemptyset(&sa.sa_mask);       // initialize signal mask to empty (no signals blocked during handler)
    sa.sa_flags = 0;    // no special flags (SA_RESTART would auto-restart interrupted system calls)

    // register the handler for SIGINT (signal number 2, generated by ctrl+C)
    // sigaction() is preferred over signal() because it's more portable and reliable
    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("sigaction");    // print error if registration fails
        exit(EXIT_FAILURE);     // exit because we can't handle interrupts safely
    }
}

/*----------UTILITY FUNCTIONS------------*/ 

// print usage information
void print_usage(const char *progname) {
    fprintf(stderr, "Usage: %s [OPTIONS] FILE1 FILE2\n", progname);
    fprintf(stderr, "\nAdvanced file comparison tool with text/binary diff and performance stats\n\n");
    fprintf(stderr, "OPTIONS:\n");
    fprintf(stderr, "  -t, --text                Force text mode comparison\n");
    fprintf(stderr, "  -b, --binary              Force binary mode comparison\n");
    fprintf(stderr, "  -s, --stats               Show performance statistics\n");
    fprintf(stderr, "  -o, --output FILENAME     Write output to FILENAME (default: stdout)\n");
    fprintf(stderr, "  -h, --help                Display this help message\n");
}

// check if a file appears to be text => return 1 if text, 0 if binary
int is_text_file(const char *data, size_t size) {
    size_t sample_size = (size < 512) ? size : 512;      // check first 512 bytes
    size_t non_text_count = 0;

    for (size_t i = 0; i < sample_size; i++) {
        unsigned char c = (unsigned char)data[i];

        // count characters that are not printable, whitespace, or common control chars
        if (c != '\n' && c != '\r' && c != '\t' && !isprint(c) && c != 0) {
            non_text_count++;
        }
    }
    // if more than 5% non-text characters, consider it binary
    return (non_text_count * 100 / sample_size) < 5;
}

// convert byte to printable character representation
char to_printable(unsigned char c) {
    return isprint(c) ? c : '.';
}

// get current time with nanosecond precision
void get_current_time(struct timespec *ts) {
    if (clock_gettime(CLOCK_MONOTONIC, ts) == -1) {
        perror("clock_gettime");
        exit(EXIT_FAILURE);
    }
}

// calculate time difference in milliseconds
double time_diff_ms(struct timespec *start, struct timespec *end) {
    double diff = (end->tv_sec - start->tv_sec) * 1000.0;
    diff += (end->tv_nsec - start->tv_nsec) / 1000000.0;
    return diff;
}

/*----------FILE OPERATIONS------------*/ 

// open and memory map a file for reading, returns pointer to mapped memory, or NULL on error
char* map_file(const char *filename, size_t *size, int *fd) {
    struct stat st;
    char *mapped;

    // open file for reading
    *fd = open(filename, O_RDONLY);
    if (*fd == -1) {
        fprintf(stderr, "Error opening file '%s': %s\n", filename, strerror(errno));
        return NULL;
    }

    // get file size using fstat
    if (fstat(*fd, &st) == -1) {
        fprintf(stderr, "Error getting file stats for '%s': %s\n", filename, strerror(errno));
        close(*fd);
        return NULL;
    }

    *size = st.st_size;

    // handle empty files
    if (*size == 0) {
        return NULL;  // empty file, return NULL but fd is valid
    }

    // memory map the file for efficient access
    // mmap treats the file as if it's in memory without loading it all at once
    mapped = mmap(NULL, *size, PROT_READ, MAP_PRIVATE, *fd, 0);
    if (mapped == MAP_FAILED) {
        fprintf(stderr, "Error mapping file '%s': %s\n", filename, strerror(errno));
        close(*fd);
        return NULL;
    }
    return mapped;
}

// unmap a memory-mapped file and close file descriptor
void unmap_file(char *mapped, size_t size, int fd) {
    if (mapped != NULL && size > 0) {
        if (munmap(mapped, size) == -1) {
            perror("munmap");
        }
    }
    if (fd >= 0) {
        close(fd);
    }
}

/*----------BINARY COMPARISONS------------*/ 

// compare two files in binary mode (byte by byte)
// returns number of differences found
size_t compare_binary(const char *data1, size_t size1, const char *data2, size_t size2, FILE *output) {
    size_t min_size = (size1 < size2) ? size1 : size2;
    size_t max_size = (size1 > size2) ? size1 : size2;
    size_t differences = 0;
    size_t offset;

    fprintf(output, "=== BINARY COMPARISON ===\n");
    fprintf(output, "File 1 size: %zu bytes\n", size1);
    fprintf(output, "File 2 size: %zu bytes\n", size2);

    if (size1 != size2) {
        fprintf(output, "WARNING: Files have different sizes (%zu vs %zu bytes)\n\n", size1, size2);
    } else {
        fprintf(output, "\n");
    }

    // compare byte by byte up to the smaller file size
    for (offset = 0; offset < min_size && !interrupted; offset++) {
        unsigned char byte1 = (unsigned char)data1[offset];
        unsigned char byte2 = (unsigned char)data2[offset];

        if (byte1 != byte2) {
            differences++;

            // print difference with hex values and ASCII representation
            fprintf(output, "Offset 0x%08zx (%zu): 0x%02x != 0x%02x  ('%c' vs '%c')\n", 
                    offset, offset, byte1, byte2, 
                    to_printable(byte1), to_printable(byte2));
        }
    }

    // if one file is longer, count remaining bytes as difference
    if (size1 != size2) {
        size_t extra_bytes = max_size - min_size;
        differences += extra_bytes;
        fprintf(output, "\nFile size difference: %zu extra bytes in %s file\n", 
                extra_bytes, (size1 > size2) ? "first" : "second");
    }

    fprintf(output, "\nTotal differences: %zu bytes (%.2f%%)\n", 
            differences, 
            max_size > 0 ? (differences * 100.0 / max_size) : 0.0);    

    return differences;
}


/*----------TEXT COMPARISON------------*/ 

// structure to represent a line in a file
typedef struct {
    const char *data;   // pointer to start of line (points into mmap'd memory)
    size_t length;      // length of a line (excluding newline)
} Line;

// parse file into lines
// returns array of Line structures (caller must free)
Line* parse_lines(const char *data, size_t size, size_t *line_count) {
    // first pass: count lines
    *line_count = 0;
    for (size_t i = 0; i < size; i++) {
        if (data[i] == '\n') {
            (*line_count)++;
        }
    }

    // if file doesn't end with newline, count last line
    if (size > 0 && data[size - 1] != '\n') {
        (*line_count)++;
    }

    if (*line_count == 0) {
        return NULL;
    }

    // allocate array for lines
    Line *lines = malloc(*line_count * sizeof(Line));
    if (lines == NULL) {
        perror("malloc");
        return NULL;
    }

    // second pass: extract lines (pointers into original data)
    size_t line_index = 0;
    size_t line_start = 0;

    for (size_t i = 0; i < size; i++) {
        if (data[i] == '\n') {
            lines[line_index].data = &data[line_start];
            lines[line_index].length = i - line_start;
            line_index++;
            line_start = i + 1;
        }
    }

    // handle last line if it doesn't end with a newline
    if (line_start < size) {
        lines[line_index].data = &data[line_start];
        lines[line_index].length = size - line_start;
    }

    return lines;
}

// compare two lines for equality => return 1 if equal, 0 if different
int lines_equal(const Line *line1, const Line *line2) {
    if (line1->length != line2->length) {
        return 0;
    }
    return memcmp(line1->data, line2->data, line1->length) == 0;
}

// print a line to output
void print_line(FILE *output, const Line *line) {
    fwrite(line->data, 1, line->length, output);
    fputc('\n', output);
}

// Compare two files in text mode (line by line) returns number of differences found
size_t compare_text(const char *data1, size_t size1, const char *data2, size_t size2, FILE *output) {
    size_t line_count1, line_count2;
    Line *lines1 = parse_lines(data1, size1, &line_count1);
    Line *lines2 = parse_lines(data2, size2, &line_count2);
    size_t differences = 0;

    fprintf(output, "=== TEXT COMPARISON ===\n");
    fprintf(output, "File 1: %zu lines\n", line_count1);
    fprintf(output, "File 2: %zu lines\n\n", line_count2);

    if (lines1 == NULL && lines2 == NULL) {
        fprintf(output, "Both files are empty.\n");
        return 0;
    }

    // compare line by line
    size_t min_lines = (line_count1 < line_count2) ? line_count1 : line_count2;

    for (size_t i = 0; i < min_lines && !interrupted; i++) {
        if (!lines_equal(&lines1[i], &lines2[i])) {
            differences++;
            fprintf(output, "Line %zu differs:\n", i + 1);
            fprintf(output, "< ");
            print_line(output, &lines1[i]);
            fprintf(output, "> ");
            print_line(output, &lines2[i]);
            fprintf(output, "\n");
        }
    }

    // handle cases where files have different number of lines
    if (line_count1 != line_count2) {
        fprintf(output, "Files have different number of lines (%zu vs %zu)\n\n", 
                line_count1, line_count2);
        
        // show lines only in file 1
        if (line_count1 > line_count2) {
            fprintf(output, "Lines only in first file:\n");
            for (size_t i = line_count2; i < line_count1 && !interrupted; i++) {
                fprintf(output, "< %zu: ", i + 1);
                print_line(output, &lines1[i]);
                differences++;
            }
            fprintf(output, "\n");
        }

        // show lines only in file 2
        if (line_count2 > line_count1) {
            fprintf(output, "Lines only in second file:\n");
            for (size_t i = line_count1; i < line_count2 && !interrupted; i++) {
                fprintf(output, "> %zu: ", i + 1);
                print_line(output, &lines2[i]);
                differences++;
            }
            fprintf(output, "\n");
        }
    }
    
    fprintf(output, "Total differing lines: %zu\n", differences);
    
    // cleanup
    free(lines1);
    free(lines2);

    return differences;
}

/*----------PERFORMANCE STATISTICS------------*/ 

// print performance statistics
void print_statistics(const PerformanceStats *stats, FILE *output) {
    double elapsed_ms = time_diff_ms((struct timespec *)&stats->start_time, 
                                     (struct timespec *)&stats->end_time);
    
    fprintf(output, "\n=== PERFORMANCE STATISTICS ===\n");
    fprintf(output, "Execution time: %.3f ms\n", elapsed_ms);
    fprintf(output, "File 1 size: %zu bytes\n", stats->file1_size);
    fprintf(output, "File 2 size: %zu bytes\n", stats->file2_size);
    fprintf(output, "Total bytes compared: %zu\n", stats->bytes_compared);
    fprintf(output, "Differences found: %zu\n", stats->differences_found);
    fprintf(output, "Memory mapping: %s\n", stats->mmap_used ? "Yes" : "No");
    
    if (elapsed_ms > 0) {
        double throughput_mb = (stats->bytes_compared / 1024.0 / 1024.0) / (elapsed_ms / 1000.0);
        fprintf(output, "Throughput: %.2f MB/s\n", throughput_mb);
    }
}

/*----------MAIN PROGRAM------------*/ 

int main(int argc, char *argv[]) {
    Options opts = {0};  // initialize all options to 0/NULL
    PerformanceStats stats = {0};
    int c, option_index;
    char *file1_path = NULL;
    char *file2_path = NULL;
    char *data1 = NULL, *data2 = NULL;
    size_t size1 = 0, size2 = 0;
    int fd1 = -1, fd2 = -1;
    FILE *output = stdout; 
    int exit_code = EXIT_SUCCESS;
    int is_text;

    // setup signal handlers for graceful interruption
    setup_signals();

    // define long options for getopt_long
    static struct option long_options[] = {
        {"text",    no_argument,       0, 't'},
        {"binary",  no_argument,       0, 'b'},
        {"stats",   no_argument,       0, 's'},
        {"output",  required_argument, 0, 'o'},
        {"help",    no_argument,       0, 'h'},
        {0, 0, 0, 0}
    };
    
    // parse command-line arguments using getopt_long
    while ((c = getopt_long(argc, argv, "tbso:h", long_options, &option_index)) != -1) {
        switch (c) {
            case 't':
                opts.force_text = 1;
                break;
            case 'b':
                opts.force_binary = 1;
                break;
            case 's':
                opts.show_stats = 1;
                break;
            case 'o':
                opts.output_file = optarg;
                break;
            case 'h':
                print_usage(argv[0]);
                return EXIT_SUCCESS;
            case '?':
                // getopt_long already printed error message
                print_usage(argv[0]);
                return 2;
            default:
                abort();
        }
    }

    // check if both text and binary modes are specified (error)
    if (opts.force_text && opts.force_binary) {
        fprintf(stderr, "Error: Cannot specify both --text and --binary modes\n");
        print_usage(argv[0]);
        return 2;
    }

    // check for required positional arguments (two file paths)
    if (optind + 2 != argc) {
        fprintf(stderr, "Error: Expected exactly two file arguments\n");
        print_usage(argv[0]);
        return 2;
    }

    file1_path = argv[optind];
    file2_path = argv[optind + 1];

    // open output file if specified
    if (opts.output_file != NULL) {
        output = fopen(opts.output_file, "w");
        if (output == NULL) {
            fprintf(stderr, "Error opening output file '%s': %s\n", 
                    opts.output_file, strerror(errno));
            return 2;
        }
    }

    // start performance timer
    get_current_time(&stats.start_time);

    // memory map both files using mmap for efficient access
    data1 = map_file(file1_path, &size1, &fd1);
    data2 = map_file(file2_path, &size2, &fd2);

    // check for file opening errors
    if (fd1 == -1 || fd2 == -1) {
        exit_code = 2;
        goto cleanup;
    }

    // handle empty files
    if (size1 == 0 && size2 == 0) {
        fprintf(output, "Both files are empty - files are identical.\n");
        goto cleanup;
    }

    if (size1 == 0 || size2 == 0) {
        fprintf(output, "One file is empty - files differ.\n");
        fprintf(output, "File 1: %zu bytes\n", size1);
        fprintf(output, "File 2: %zu bytes\n", size2);
        stats.differences_found = (size1 > size2) ? size1 : size2;
        exit_code = 1; // files differ, so exit code should be 1
        goto cleanup;
    }

    // update statistics
    stats.file1_size = size1;
    stats.file2_size = size2;
    stats.bytes_compared = (size1 < size2) ? size1 : size2;
    stats.mmap_used = 1;

    // determine comparison mode (text or binary)
    if (opts.force_text) {
        is_text = 1;
    } else if (opts.force_binary) {
        is_text = 0;
    } else {
        // auto detect based on file content heuristic
        is_text = is_text_file(data1, size1) && is_text_file(data2, size2);
    }

    // perform comparison based on mode
    if (is_text) {
        stats.differences_found = compare_text(data1, size1, data2, size2, output);
    } else {
        stats.differences_found = compare_binary(data1, size1, data2, size2, output);
    }

    // check if interrupted by signal
    if (interrupted) {
        fprintf(stderr, "\nComparison interrupted by user\n");
        exit_code = 2;
    }

    // stop performance timer
    get_current_time(&stats.end_time);

    // print statistics if requested
    if (opts.show_stats) {
        print_statistics(&stats, output);
    }

    // determine exit code based on differences
    // 0 = files identical, 1 = files differ, 2 = error
    if (exit_code == EXIT_SUCCESS) {
        exit_code = (stats.differences_found > 0) ? 1 : 0;
    }

cleanup: 
    // cleanup: unmap files and close file descriptors
    unmap_file(data1, size1, fd1);
    unmap_file(data2, size2, fd2);

    // close output file if it was opened
    if (output != stdout) {
        fclose(output);
    }
    return exit_code;
}